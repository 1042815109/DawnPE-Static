<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸš€ ç™¾ä¸‡ç“¦å°é‡‘åº“</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        h1 {
            text-align: center;
            color: #4a5568;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .download-section {
            margin: 20px 0;
            padding: 20px;
            /*border: 2px dashed #e2e8f0;*/
            border-radius: 10px;
            text-align: center;
        }

        .download-btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 15px;
            border-radius: 18px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        .download-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .download-btn:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .progress-container {
            margin: 20px 0;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e2e8f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }

        .status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            font-weight: bold;
        }

        .status.info {
            background: #bee3f8;
            color: #2b6cb0;
        }

        .status.success {
            background: #c6f6d5;
            color: #2f855a;
        }

        .status.error {
            background: #fed7d7;
            color: #c53030;
        }

        .file-info {
            background: #f7fafc;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #667eea;
        }

        .file-info h3 {
            margin: 0 0 10px 0;
            color: #4a5568;
        }

        .file-info p {
            margin: 5px 0;
            color: #718096;
        }

        .config-section {
            display: none;
            margin: 20px 0;
            padding: 20px;
            background: #f7fafc;
            border-radius: 10px;
        }

        .config-section h3 {
            margin: 0 0 15px 0;
            color: #4a5568;
        }

        .config-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #e2e8f0;
            border-radius: 5px;
            font-size: 14px;
            margin: 5px 0;
        }

        .config-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .file-info div[style*='display: flex'] {
            /* ä¿è¯é»˜è®¤æ¨ªå‘æ’åˆ— */
            flex-direction: row;
        }
        @media (max-width: 600px) {
            .file-info div[style*='display: flex'] {
                flex-direction: column !important;
                align-items: stretch !important;
                gap: 10px !important;
            }
            .file-info .download-btn {
                min-width: unset !important;
                width: 100%;
                margin-left: 0 !important;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸš€ ç™¾ä¸‡ç“¦å°é‡‘åº“</h1>
        
        <div class="config-section">
            <h3>ğŸ“‹ é…ç½®æ–‡ä»¶è®¾ç½®</h3>
            <div style="display: flex; align-items: center; gap: 10px;">
                <label for="configUrl" style="margin: 0; white-space: nowrap;">é…ç½®æ–‡ä»¶è·¯å¾„:</label>
                <input type="text" id="configUrl" class="config-input" value="./config.json" placeholder="è¾“å…¥config.jsonçš„è·¯å¾„" style="width: 220px; max-width: 60vw; display: inline-block;">
            </div>
            <p style="font-size: 10px; color: #718096; margin-top: 5px;">
                é»˜è®¤ä½¿ç”¨å½“å‰ç›®å½•ä¸‹çš„config.jsonæ–‡ä»¶ï¼Œå¯é€šè¿‡URLå‚æ•° ?config= ç›´æ¥è®¾ç½®é…ç½®æ–‡ä»¶è·¯å¾„
            </p>
        </div>

        <div class="file-info" id="fileInfo" style="display: none; flex-direction: column; gap: 16px;"></div>

        <div class="progress-container" id="progressContainer">
            <div class="status info" id="status">å‡†å¤‡ä¸‹è½½...</div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div id="progressText">0%</div>
        </div>
    </div>

    <script src="./StreamSaver.min.js"></script>
    <script>
        let downloadInProgress = false;
        let totalChunks = 0;
        let processedChunks = 0;

        async function startDownload(fileKey, options = {}) {
            if (downloadInProgress) {
                alert('ä¸‹è½½æ­£åœ¨è¿›è¡Œä¸­ï¼Œè¯·ç­‰å¾…å®Œæˆ');
                return;
            }
            const configUrl = document.getElementById('configUrl').value.trim() || './config.json';
            const progressContainer = document.getElementById('progressContainer');
            const status = document.getElementById('status');
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            try {
                downloadInProgress = true;
                document.querySelectorAll('.download-btn').forEach(btn => { btn.disabled = true; btn.textContent = 'â³ ä¸‹è½½ä¸­...'; });
                progressContainer.style.display = 'block';
                status.textContent = 'æ­£åœ¨è·å–é…ç½®æ–‡ä»¶...';
                status.className = 'status info';
                // è·å–é…ç½®æ–‡ä»¶
                const configResponse = await fetch(configUrl);
                if (!configResponse.ok) {
                    throw new Error(`é…ç½®æ–‡ä»¶è·å–å¤±è´¥: ${configResponse.status}`);
                }
                const config = await configResponse.json();
                const file = config.files[fileKey];
                if (!file) throw new Error('é…ç½®æ–‡ä»¶æ— æœ‰æ•ˆæ–‡ä»¶ä¿¡æ¯');
                const totalChunks = file.chunks.length;
                const totalSize = file.metadata && file.metadata.size ? file.metadata.size : 0;
                const chunksSize = file.metadata && file.metadata.chunksSize ? file.metadata.chunksSize : [];
                let downloadedBytes = 0;
                let processedChunks = 0;
                // è®¡ç®—æ¯ä¸ªåˆ†ç‰‡çš„èµ·å§‹ä½ç½®
                const chunkPositions = [];
                let currentPosition = 0;
                for (let i = 0; i < file.chunks.length; i++) {
                    chunkPositions.push(currentPosition);
                    currentPosition += chunksSize[i] || 0;
                }
                // ä¼˜å…ˆç”¨fsaa
                let useFsaa = !!window.showSaveFilePicker;
                let fileHandle, writable;
                try {
                    if (useFsaa && !options.onlyStreamSaver) {
                        status.textContent = 'æ­£åœ¨è¯·æ±‚ä¿å­˜ä½ç½®...';
                        fileHandle = await window.showSaveFilePicker({
                            suggestedName: fileKey,
                            types: [{
                                description: 'æ‰€æœ‰æ–‡ä»¶',
                                accept: {'*/*': ['.' + fileKey.split('.').pop()]}
                            }]
                        });
                        writable = await fileHandle.createWritable();
                        status.textContent = 'æ­£åœ¨ä¸‹è½½...';
                        for (let i = 0; i < totalChunks; i++) {
                            const chunkName = file.chunks[i];
                            const chunkUrl = getChunkUrl(chunkName);
                            const resp = await fetch(chunkUrl);
                            if (!resp.ok) throw new Error(`åˆ†ç‰‡è·å–å¤±è´¥: ${chunkName}`);
                            const reader = resp.body.getReader();
                            let written = 0;
                            while (true) {
                                const { done, value } = await reader.read();
                                if (done) break;
                                await writable.write({ type: 'write', position: chunkPositions[i] + written, data: value });
                                written += value.length;
                                downloadedBytes += value.length;
                                const progress = totalSize ? (downloadedBytes / totalSize) * 100 : (processedChunks / totalChunks) * 100;
                                updateProgress(progress, downloadedBytes, totalSize);
                            }
                            reader.releaseLock();
                            processedChunks++;
                        }
                        status.textContent = 'æ­£åœ¨åˆå¹¶æ–‡ä»¶...';
                        status.className = 'status info';
                        await writable.close();
                        status.textContent = 'âœ… ä¸‹è½½å®Œæˆï¼';
                        status.className = 'status success';
                        progressFill.style.width = '100%';
                        progressText.textContent = totalSize ? `${formatSize(totalSize)}/${formatSize(totalSize)} (100%)` : '100%';
                    } else if (!useFsaa && options.onlyFsaa) {
                        throw new Error('fsaaä¸æ”¯æŒæˆ–æœªæˆæƒ');
                    } else if (!options.onlyFsaa) {
                        throw new Error('fsaaä¸æ”¯æŒæˆ–æœªæˆæƒ');
                    }
                } catch (fsaaErr) {
                    // é™çº§ä¸ºstreamsaver
                    if (options.onlyFsaa) throw fsaaErr;
                    if (options.onlyStreamSaver) {
                        status.textContent = 'æ­£åœ¨ä½¿ç”¨StreamSaverä¸‹è½½...';
                        status.className = 'status info';
                    } else {
                        status.textContent = 'æ­£åœ¨ä½¿ç”¨å…¼å®¹æ¨¡å¼ï¼ˆStreamSaverï¼‰ä¸‹è½½...';
                        status.className = 'status info';
                    }
                    const fileStream = window.streamSaver.createWriteStream(fileKey);
                    const writer = fileStream.getWriter();
                    for (let i = 0; i < totalChunks; i++) {
                        const chunkName = file.chunks[i];
                        const chunkUrl = getChunkUrl(chunkName);
                        const resp = await fetch(chunkUrl);
                        if (!resp.ok) throw new Error(`åˆ†ç‰‡è·å–å¤±è´¥: ${chunkName}`);
                        const reader = resp.body.getReader();
                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;
                            await writer.write(value);
                            if (value) downloadedBytes += value.length;
                            const progress = totalSize ? (downloadedBytes / totalSize) * 100 : (processedChunks / totalChunks) * 100;
                            updateProgress(progress, downloadedBytes, totalSize);
                        }
                        reader.releaseLock();
                        processedChunks++;
                    }
                    status.textContent = 'æ­£åœ¨åˆå¹¶æ–‡ä»¶...';
                    status.className = 'status info';
                    await writer.close();
                    status.textContent = 'âœ… ä¸‹è½½å®Œæˆï¼ï¼ˆå…¼å®¹æ¨¡å¼ï¼‰';
                    status.className = 'status success';
                    progressFill.style.width = '100%';
                    progressText.textContent = totalSize ? `${formatSize(totalSize)}/${formatSize(totalSize)} (100%)` : '100%';
                }
            } catch (error) {
                console.error('ä¸‹è½½é”™è¯¯:', error);
                status.textContent = `âŒ ä¸‹è½½å¤±è´¥: ${error.message}`;
                status.className = 'status error';
            } finally {
                downloadInProgress = false;
                document.querySelectorAll('.download-btn').forEach(btn => { btn.disabled = false; btn.textContent = 'ğŸ“¥ å¼€å§‹ä¸‹è½½'; });
            }
        }

        function getChunkUrl(chunkName) {
            const host = window.location.origin;
            if (chunkName.startsWith('http://') || chunkName.startsWith('https://')) {
                return chunkName;
            }
            if (chunkName.startsWith('/')) {
                return `${host}${chunkName}`;
            }
            return `${host}/${chunkName}`;
        }

        async function showFileInfo(configUrl) {
            try {
                const response = await fetch(configUrl);
                if (!response.ok) return;
                
                const config = await response.json();
                const fileInfo = document.getElementById('fileInfo');
                fileInfo.innerHTML = '';
                Object.entries(config.files).forEach(([key, file]) => {
                    const size = file.metadata && file.metadata.size ? file.metadata.size : 0;
                    // æ¯ä¸ªæ–‡ä»¶ä¸€è¡Œï¼Œå³ä¾§æœ‰ä¸‹è½½æŒ‰é’®
                    const row = document.createElement('div');
                    row.style.display = 'flex';
                    row.style.alignItems = 'center';
                    row.style.justifyContent = 'space-between';
                    row.style.gap = '20px';
                    row.innerHTML = `<div style='flex:1;'><strong>${key}</strong><br><span style='color:#718096;'>${formatSize(size)}</span></div>`;
                    const btn = document.createElement('button');
                    btn.className = 'download-btn';
                    btn.style.minWidth = '140px';
                    btn.textContent = 'ğŸ“¥ å¼€å§‹ä¸‹è½½';
                    btn.onclick = () => startDownload(key);
                    row.appendChild(btn);
                    // æé€Ÿä¸‹è½½æŒ‰é’®
                    const fastBtn = document.createElement('button');
                    fastBtn.className = 'download-btn';
                    fastBtn.style.minWidth = '120px';
                    fastBtn.style.marginLeft = '8px';
                    fastBtn.textContent = 'âš¡ æé€Ÿä¸‹è½½';
                    fastBtn.style.background = 'linear-gradient(45deg, #38a169, #48bb78)';
                    fastBtn.style.boxShadow = '0 4px 15px rgba(56, 161, 105, 0.4)';
                    fastBtn.onclick = () => fastDownload(key);
                    row.appendChild(fastBtn);
                    fileInfo.appendChild(row);
                });
                fileInfo.style.display = 'flex';
            } catch (error) {
                console.error('è·å–æ–‡ä»¶ä¿¡æ¯å¤±è´¥:', error);
            }
        }

        function updateProgress(percentage, downloadedBytes, totalSize) {
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            const status = document.getElementById('status');
            
            progressFill.style.width = `${percentage}%`;
            if (totalSize) {
                progressText.textContent = `${formatSize(downloadedBytes)}/${formatSize(totalSize)} (${Math.round(percentage)}%)`;
                status.textContent = `ä¸‹è½½è¿›åº¦: ${formatSize(downloadedBytes)}/${formatSize(totalSize)} (${Math.round(percentage)}%)`;
            } else {
                progressText.textContent = `${Math.round(percentage)}%`;
                status.textContent = `ä¸‹è½½è¿›åº¦: ${processedChunks}/${totalChunks} åˆ†ç‰‡ (${Math.round(percentage)}%)`;
            }
        }

        // æ–‡ä»¶å¤§å°æ ¼å¼åŒ–å‡½æ•°
        function formatSize(bytes) {
            if (bytes >= 1024 * 1024 * 1024) {
                return (bytes / (1024 * 1024 * 1024)).toFixed(2) + ' GB';
            } else if (bytes >= 1024 * 1024) {
                return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
            } else if (bytes >= 1024) {
                return (bytes / 1024).toFixed(2) + ' KB';
            } else {
                return bytes + ' B';
            }
        }

        // é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨è·å–æ–‡ä»¶ä¿¡æ¯
        window.addEventListener('load', () => {
            // æ”¯æŒé€šè¿‡URLå‚æ•°configæŒ‡å®šé…ç½®æ–‡ä»¶è·¯å¾„
            function getQueryParam(name) {
                const params = new URLSearchParams(window.location.search);
                return params.get(name);
            }
            const configInput = document.getElementById('configUrl');
            const urlConfig = getQueryParam('config');
            if (urlConfig) {
                configInput.value = urlConfig;
            }
            const configUrl = configInput.value;

            // fileå‚æ•°æœ€é«˜ä¼˜å…ˆçº§ï¼Œç›´æ¥é‡å®šå‘
            const fileParam = getQueryParam('file');
            if (fileParam) {
                const { protocol, host } = window.location;
                window.location.href = `${protocol}//${host}/range/${fileParam}`;
                return;
            }

            // å…¶ä½™å‚æ•°åœ¨configåŠ è½½åå†å¤„ç†
            const blobParam = getQueryParam('blob');
            const fsaaParam = getQueryParam('fsaa');
            const streamParam = getQueryParam('streamsaver') || getQueryParam('stream');

            // showFileInfoåŠ è½½åè‡ªåŠ¨è§¦å‘ä¸‹è½½
            function autoDownloadAfterConfig() {
                if (blobParam) {
                    fastDownload(blobParam);
                } else if (fsaaParam) {
                    startDownload(fsaaParam, { onlyFsaa: true });
                } else if (streamParam) {
                    startDownload(streamParam, { onlyStreamSaver: true });
                }
            }
            showFileInfo(configUrl);
            setTimeout(autoDownloadAfterConfig, 0); // ä¿è¯æ¸²æŸ“åå†è§¦å‘
            
            // æ˜¾ç¤ºå½“å‰è·¯å¾„ä¿¡æ¯
            showPathInfo();

            // ç›‘å¬configUrlè¾“å…¥æ¡†å¤±å»ç„¦ç‚¹æˆ–å›è½¦ï¼Œåˆ·æ–°æ–‡ä»¶åˆ—è¡¨
            configInput.addEventListener('blur', function() {
                showFileInfo(this.value.trim() || './config.json');
            });
            configInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    showFileInfo(this.value.trim() || './config.json');
                }
            });
        });

        function showPathInfo() {
            const currentPath = window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/') + 1);
            const host = window.location.origin;
            
            console.log('å½“å‰é¡µé¢è·¯å¾„:', currentPath);
            console.log('å½“å‰åŸŸå:', host);
            console.log('å®Œæ•´URL:', host + currentPath);
            
            // åœ¨é¡µé¢ä¸Šæ˜¾ç¤ºè·¯å¾„ä¿¡æ¯ï¼ˆå¯é€‰ï¼‰
            const pathInfo = document.createElement('div');
            pathInfo.style.cssText = 'background: #f0f0f0; padding: 10px; margin: 10px 0; border-radius: 5px; font-size: 12px; color: #666;';
            pathInfo.innerHTML = `
                <strong>è·¯å¾„ä¿¡æ¯:</strong><br>
                å½“å‰é¡µé¢è·¯å¾„: ${currentPath}<br>
                åŸŸå: ${host}<br>
                å®Œæ•´URL: ${host}${currentPath}
            `;
            
            // å°†è·¯å¾„ä¿¡æ¯æ’å…¥åˆ°é…ç½®åŒºåŸŸåé¢
            const configSection = document.querySelector('.config-section');
            configSection.appendChild(pathInfo);
        }

        // æé€Ÿä¸‹è½½å®ç°ï¼ˆå§‹ç»ˆå…¨å†…å­˜é«˜å¹¶å‘blobï¼‰
        async function fastDownload(fileKey) {
            if (downloadInProgress) {
                alert('ä¸‹è½½æ­£åœ¨è¿›è¡Œä¸­ï¼Œè¯·ç­‰å¾…å®Œæˆ');
                return;
            }
            const configUrl = document.getElementById('configUrl').value.trim() || './config.json';
            const progressContainer = document.getElementById('progressContainer');
            const status = document.getElementById('status');
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            try {
                downloadInProgress = true;
                document.querySelectorAll('.download-btn').forEach(btn => { btn.disabled = true; });
                progressContainer.style.display = 'block';
                status.textContent = 'æ­£åœ¨è·å–é…ç½®æ–‡ä»¶...';
                status.className = 'status info';
                // è·å–é…ç½®æ–‡ä»¶
                const configResponse = await fetch(configUrl);
                if (!configResponse.ok) throw new Error(`é…ç½®æ–‡ä»¶è·å–å¤±è´¥: ${configResponse.status}`);
                const config = await configResponse.json();
                const file = config.files[fileKey];
                if (!file) throw new Error('é…ç½®æ–‡ä»¶æ— æœ‰æ•ˆæ–‡ä»¶ä¿¡æ¯');
                const totalSize = file.metadata && file.metadata.size ? file.metadata.size : 0;
                const chunksSize = file.metadata && file.metadata.chunksSize ? file.metadata.chunksSize : [];
                const concurrentDownload = file.metadata && file.metadata.concurrentDownload ? file.metadata.concurrentDownload : 3;
                const totalChunks = file.chunks.length;
                let downloadedBytes = 0;
                let completedChunks = 0;
                // è®¡ç®—æ¯ä¸ªåˆ†ç‰‡çš„èµ·å§‹ä½ç½®
                let chunkOffsets = [];
                let pos = 0;
                for (let i = 0; i < totalChunks; i++) {
                    chunkOffsets.push(pos);
                    pos += chunksSize[i] || 0;
                }
                // é¢„åˆ†é…å¤§å†…å­˜
                const buffer = new Uint8Array(totalSize);
                // å¹¶å‘ä¸‹è½½æ‰€æœ‰åˆ†ç‰‡
                let errorOccurred = false;
                async function downloadChunkToBuffer(chunkIndex, buffer, offset) {
                    const chunkName = file.chunks[chunkIndex];
                    const chunkUrl = getChunkUrl(chunkName);
                    const resp = await fetch(chunkUrl);
                    if (!resp.ok) throw new Error(`åˆ†ç‰‡è·å–å¤±è´¥: ${chunkName}`);
                    const reader = resp.body.getReader();
                    let written = 0;
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        buffer.set(value, offset + written);
                        written += value.length;
                        downloadedBytes += value.length;
                        const progress = totalSize ? (downloadedBytes / totalSize) * 100 : (completedChunks / totalChunks) * 100;
                        updateProgress(progress, downloadedBytes, totalSize);
                    }
                    reader.releaseLock();
                }
                await Promise.all(Array.from({length: totalChunks}, (_, i) =>
                    downloadChunkToBuffer(i, buffer, chunkOffsets[i]).then(() => {
                        completedChunks++;
                        status.textContent = `æé€Ÿä¸‹è½½ï¼š${completedChunks}/${totalChunks} åˆ†ç‰‡`;
                    }).catch(err => {
                        errorOccurred = true;
                        throw err;
                    })
                ));
                if (errorOccurred) throw new Error('æœ‰åˆ†ç‰‡ä¸‹è½½å¤±è´¥');
                // åˆå¹¶æç¤º
                status.textContent = 'æ­£åœ¨åˆå¹¶æ–‡ä»¶...';
                status.className = 'status info';
                // åˆå¹¶æ‰€æœ‰åˆ†ç‰‡
                const mergedBlob = new Blob([buffer]);
                // è§¦å‘æµè§ˆå™¨ä¸‹è½½
                const blobUrl = URL.createObjectURL(mergedBlob);
                const a = document.createElement('a');
                a.href = blobUrl;
                a.download = fileKey;
                document.body.appendChild(a);
                a.click();
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(blobUrl);
                }, 1000);
                status.textContent = 'âœ… æé€Ÿä¸‹è½½å®Œæˆï¼';
                status.className = 'status success';
                progressFill.style.width = '100%';
                progressText.textContent = totalSize ? `${formatSize(totalSize)}/${formatSize(totalSize)} (100%)` : '100%';
            } catch (error) {
                console.error('æé€Ÿä¸‹è½½é”™è¯¯:', error);
                status.textContent = `âŒ æé€Ÿä¸‹è½½å¤±è´¥: ${error.message}`;
                status.className = 'status error';
            } finally {
                downloadInProgress = false;
                document.querySelectorAll('.download-btn').forEach(btn => { btn.disabled = false; });
            }
        }
    </script>
</body>
</html> 